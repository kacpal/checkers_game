
# roadmap
3. Stan gry
 - zasady remisu

4. MinMax - algorytm podpowiadający (najlepsze) ruchy.
 - optymalizacja klonowania
 - alpha-beta pruning
 - wymuszanie wielokrotnego bicia w razie takiej możliwości
 - optymalizacja oceniania wartości planszy (można wziąć pod uwagę pozycje przy ścianach)

---

5. GUI
6. Efekty dźwiękowe
7. Gra sieciowa
8. Inne warianty gry w warcaby?


# work-in-progress

interfaces
minmaxAI


# scratchpad

class ComputerPlayer implements Player {}

/*
        int bestScore = isMax ? -1000 : 1000;
        int currentScore = 0;

        ArrayList<FieldPair> validMoves = generateValidMoves(b, side);
        System.out.println(validMoves);
        bestMove = null;

        for (FieldPair currentMove : validMoves) {
            Board boardClone = b.clone();

            int move = boardClone.movePawn(boardClone.getField(currentMove.first.x, currentMove.first.y),
                    boardClone.getField(currentMove.second.x, currentMove.second.y));
            if (move < 0) {
                System.out.println("[debug] wrong move");
                return 0;
            } else {
                currentScore = minimax(boardClone, changeColor(side), depth - 1, !isMax, alpha, beta);
                if (isMax) {
                    if (currentScore > bestScore) {
                        bestScore = currentScore;
                        bestMove = currentMove;
                    }
                } else {
                    if (currentScore < bestScore) {
                        bestScore = currentScore;
                        bestMove = currentMove;
                    }
                }
            }
        }
        return bestScore;
    }

 */

Może warto by wiedzieć, jakie pionki posiada gracz? Ile ich zostało i na jakich są polach.
Do rozważenia - ew. implementacja w klasie HumanPlayer.
